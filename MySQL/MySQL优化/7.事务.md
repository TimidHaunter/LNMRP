https://www.chanmufeng.com/posts/storage/MySQL/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E4%B8%8EMVCC.html



## 1.事务定义

**事务**就是包含有限个（单条或多条）数据库操作（增删改查）的、最小的逻辑工作单元（原子性）（不可再分）。保证数据最终的一致性。

事务的英文是transaction，直译为“交易”的意思。

![tr](G:\data\LNMRP\$Image\Redis\tr.png)

>A 账户余额-100
>
>B 账户余额+100

目前只有InnoDB和NDB存储引擎支持事务。



## 2.事务的特性

**ACID**

- 原子性（Atomicity）：当前事务的操作要么同时成功，要么同时失败。原子性由undo log日志来保证。
- 一致性（Consistency）：使用事务的最终目的，由**业务代码**正确逻辑保证。
- 隔离性（lsolation）：在事务并发执行时，他们内部的操作不能互相干扰。
- 持久性（Durability）：一旦提交了事务，它对数据库的改变就应该是永久性的持久性由redo log日志来保证。



## 2.1.undo log

> 生成订单，扣减库存
>
> insert 订单表，生成记录，id如果是2
>
> undo log日志，生成一个delete id=2记录



## 2.2.隔离性

lnnoDB引擎中，定义了四种隔离级别供我们使用，级别越高事务隔离性越好，但性能就越低，而隔离性是由MySQL的各种锁以及MVCC机制来实现的。MySQL**默认**是【REPEATABLE-READ】。

- read uncommit（读未提交）：有脏读问题
- read commit（读已提交）：有不可重复读问题
- repeatable read（可重复读）：有读问题
- serializable（串行）：上面问题全部解决

```sql
##查看当前数据库使用的事务隔离级别
show variables like 'tx_isolation';

##设置事务隔离级别
set tx_isolation='read-uncommit';

##MySQL版本8.0以上，两种查看当前数据库使用的事务隔离级别方法
show variables like 'transaction_isolation';
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.00 sec)

select @@transaction_isolation;
+-------------------------+
| @@transaction_isolation |
+-------------------------+
| REPEATABLE-READ         |
+-------------------------+
1 row in set (0.00 sec)

##设置事务隔离级别
set transaction_isolation='read-uncommit';
```



```sql
##表结构和数据
mysql> select * from account;
+----+-----------+---------+
| id | name      | balance |
+----+-----------+---------+
|  1 | LiLei     | 0       |
|  2 | HanMeimei | 10000   |
|  3 | Lucy      | 20000   |
+----+-----------+---------+
3 rows in set (0.00 sec)
```



### 2.2.1.读未提交，有脏读的问题

事务B读了事务A还没有提交的数据。

```sql
##---客户端A开始---
set transaction_isolation='read-uncommitted';

##开启事务
BEGIN;
update account set balance=balance+500 where id=1;
##---客户端A结束---

##---客户端B开始---
set transaction_isolation='read-uncommitted';

##开启事务
BEGIN;
select * from account where id=1;
##---客户端B结束---

##---客户端B读到的结果---
mysql> select * from account where id=1;
+----+-------+---------+
| id | name  | balance |
+----+-------+---------+
|  1 | LiLei | 500     |
+----+-------+---------+
1 row in set (0.00 sec)



##客户端A再执行数据回滚
RollBack;

##客户端B读到的结果
mysql> select * from account where id=1;
+----+-------+---------+
| id | name  | balance |
+----+-------+---------+
|  1 | LiLei | 0       |
+----+-------+---------+
1 row in set (0.00 sec)
```



### 2.2.2.读已提交，有不可重复读问题

```sql
##---客户端A开始---
set transaction_isolation='read-committed';

##开启事务
BEGIN;
update account set balance=balance+500 where id=1;
##---客户端A结束---

##---客户端B开始---
set transaction_isolation='read-committed';

##开启事务
BEGIN;
select * from account where id=1;
##---客户端B结束---

##---客户端B读到的结果---
mysql> select * from account where id=1;
+----+-------+---------+
| id | name  | balance |
+----+-------+---------+
|  1 | LiLei | 0       |
+----+-------+---------+
1 row in set (0.00 sec)



##---客户端A开始---
set transaction_isolation='read-committed';

##开启事务
BEGIN;
update account set balance=balance+500 where id=1;
COMMIT;
##---客户端A结束---

##---客户端B开始---
set transaction_isolation='read-committed';

##开启事务
BEGIN;
select * from account where id=1;
##---客户端B结束---

##客户端B读到的结果
mysql> select * from account where id=1;
+----+-------+---------+
| id | name  | balance |
+----+-------+---------+
|  1 | LiLei | 500     |
+----+-------+---------+
1 row in set (0.00 sec)


##---会出现的问题---
##---客户端A开始---
set transaction_isolation='read-committed';

##开启事务
BEGIN;
update account set balance=balance+500 where id=1;
COMMIT;

BEGIN;
update account set balance=balance+300 where id=1;
COMMIT;
##---客户端A结束---

##---客户端B开始---
set transaction_isolation='read-committed';

##开启事务
BEGIN;
select * from account where id=1;
select * from account where id=1;
select * from account where id=1;
##---客户端B结束---

##客户端B读到的结果
可能是0,500,800
```



### 2.2.3.可重复读，有幻读问题

```sql
##---客户端A开始---
set transaction_isolation='repeatable-read';

##开启事务
BEGIN;
update account set balance=balance+500 where id=1;
COMMIT;

BEGIN;
update account set balance=balance+200 where id=1;
COMMIT;

BEGIN;
update account set balance=balance+300 where id=1;
COMMIT;
##---客户端A结束---

##---客户端B开始---
set transaction_isolation='repeatable-read';

##开启事务
BEGIN;
##500
select * from account where id=1; 
##500
select * from account where id=1;
##500
select * from account where id=1;
##---客户端B结束---

##在客户端B当前事务中查，都是500。在一个事务中，多次读到同一个数据，都以第一次读到的数据为准。【快照】

##---会出现的问题---
##幻读，读到的数据都是500
```



### 2.2.4.串型化

事务排队执行，commit才算结束。效率太低。

```sql
##---客户端B开始---
set transaction_isolation='serializable';
```



## 3.四大隔离级别原理

### 锁

- 读锁 （共享锁、S锁）

```sql
select ... lock in share mode;
```

读锁是共享的，多个事务可以同时读取同一个资源，但不允许其他事务修改。



- 写锁（排它锁、X锁）

```sql
 select ... for update;
```

写锁是排他的，会阻塞其他的写锁和读锁，**update、 delete、insert** 默认都会加写锁。



事务提交，回滚的时候，释放行锁。



### 3.1.串型化

```sql
##在【读未提交】实现串行化，解决脏读风险
##---客户端A开始---
set transaction_isolation='read-uncommitted';

##开启事务
BEGIN;
update account set balance=balance+500 where id=1;



##---客户端B开始---
set transaction_isolation='read-uncommitted';

##开启事务
BEGIN;
##500
select * from account where id=1 lock in share mode;

##因为A没有commit，B的读被加锁，所以查询被阻塞，实现了串行化
##select * from account where id=1 lock in share mode
##> 1205 - Lock wait timeout exceeded; try restarting transaction
##> 时间: 50.006s
```



### MVCC机制







