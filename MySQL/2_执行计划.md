# type


# Extra
```sql
# 数据准备
create table user_extra (
    id int primary key,
    name varchar(20),
    sex varchar(5),
    index(name)
)engine=innodb;

insert into user_extra values(1, 'shenjian','no');
insert into user_extra values(2, 'zhangsan','no');
insert into user_extra values(3, 'lisi', 'yes');
insert into user_extra values(4, 'lisi', 'no');
```
数据说明：

> 用户表：id主键索引，name普通索引（非唯一），sex无索引
>
> 插入数据：其中name普通索引存在重复数据lisi

## Using index

性能提升，`索引覆盖`，SQL所需要返回的所有列数据均在一棵索引树上，而无需访问实际的行记录（只查询索引表，不需要回表查询）。

```sql
explain  select id,name from user_extra where name='shenjian' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: user_extra
   partitions: NULL
         type: ref
possible_keys: name
          key: name
      key_len: 83
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)
```

**那么，什么样的列数据，会包含在索引树上呢？**

## Using where
需要回表查询，假设 `name` 是索引列，但是查询语句 `sex` 是没有索引的，就需要回表查询。
```sql
explain select name,sex from user_extra where sex='' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: user_extra
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 4
     filtered: 25.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

## Using filesort

## Using temporary
性能损耗比较大，用到了临时表。一般用于 `group by` 语句中。

```sql
# 建表的时候加上索引
create table test_temporary
(
    a1 char(3),
    a2 char(3),
    a3 char(3),
    a4 char(3),
    # 创建一个复合索引
    index idx_a1_a2_a3_a4(a1, a2, a3, a4)
);

explain
select * from test_temporary where a1 in('1', '2', '3') group by a1;

# 查的时候按a1，分组的时候按a2
explain
select * from test_temporary where a1 in('1', '2', '3') group by a2;

mysql> explain select * from test_temporary where a1 in('1', '2', '3') group by a1\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: test_temporary
   partitions: NULL
         type: index
possible_keys: idx_a1_a2_a3_a4
          key: idx_a1_a2_a3_a4
      key_len: 52
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using where; Using index
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from test_temporary where a1 in('1', '2', '3') group by a2\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: test_temporary
   partitions: NULL
         type: index
possible_keys: idx_a1_a2_a3_a4
          key: idx_a1_a2_a3_a4
      key_len: 52
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using where; Using index; Using temporary
1 row in set, 1 warning (0.00 sec)
```

避免：查询那些列，就根据那些列分组

## Using join buffer
MySQL 引擎使用了链接缓存，SQL写的太差了，MySQL给你加的。