https://www.chanmufeng.com/posts/storage/MySQL/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E4%B8%8EMVCC.html



## 1.事务定义

**事务**就是包含有限个（单条或多条）数据库操作（增删改查）的、最小的逻辑工作单元（不可再分）。

事务的英文是transaction，直译为“交易”的意思。

>A 账户余额-100
>
>B 账户余额+100

目前只有InnoDB和NDB存储引擎支持事务。



## 2.MySql 事务语法



### 2.1.自动提交

当我运行这样单独一条更新语句的时候，它会有事务吗？

```sql
UPDATE user SET name = 'Yintian' WHERE id = 1;
```

 MySQL默认使用**自动提交**事务。在此方式下，增删改的SQL语句会自动开启事务，并且是一条SQL一个事务。

自动提交的方式虽然简单，但是对于转账这种涉及到多条SQL的业务，就不太适合了。因此，MySQL提供了手动开启事务的方法。



### 2.2.手动操作

#### 2.2.1.开启事务

可以使用下面两种语句开启一个事务

- `BEGIN`

- `START TRANSACTION`

>对比`BEGIN`而言，`START TRANSACTION`后面可以添加一些操作符，不过这不是我们的研究重点，可以不必理会。



#### 2.2.2. 提交或回滚

开启事务之后就可以继续编写需要放到当前事务中的SQL语句了。当写完最后一条语句，如果你觉得写得没问题，你可以提交事务；反之你后悔了，想把数据库恢复到之前的状态，你可以回滚事务。

- 提交事务 `COMMIT`
- 回滚事务 `ROLLBACK`



### 2.3. autocommit系统变量

MySQL提供了一个叫做`autocommit`的系统变量，用来表示是否开启自动提交：

```mysql
mysql> SHOW VARIABLES LIKE 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
```

`autocommit`的默认值为`ON`，表示默认开启自动提交。但是自动提交和手动操作事务并不冲突，如果不显式使用`BEGIN`或`START TRANSACTION`开启一个事务，那么InnoDB会在每一条增删改语句执行之后提交事务。

如果我们把`autocommit`设为`OFF`，除非我们手动使用`BEGIN`或`START TRANSACTION`开启一个事务，否则InnoDB绝不会自动开启事务；同样，除非我们使用`COMMIT`或`ROLLBACK`提交或回滚事务，否则InnoDB不会自动结束事务。

> 实际上，InnoDB会因为**某些特殊语句的执行**或**客户端连接断开**等特殊情况而导致事务自动提交（即使我们没有手动输入`COMMIT`），这种情况叫做**隐式提交**。



##  3. 事务并发执行导致的读问题

MySQL会使用独立的线程处理每一个客户端的连接，这就是多线程。每个线程都可以开启事务，这就是事务的并发。

不管是多线程的并发执行还是事务的并发执行（其实本质上是一回事儿），如果不采取点措施，都会带来一些问题。

### 3.1. 脏读

假设事务`T1`和`T2`并发执行，都要访问`user`表中`id`为`1`的数据，不同的是`T1`先读取数据，紧接着`T2`修改了数据的`name`字段，需要注意的是，`T2`并没有提交！

![image-20220418142616460](G:\data\LNMRP\$Image\Redis\20.png)

此时，`T1`再次执行相同的查询操作，会发现数据发生了变化，`name`字段由「王刚蛋」变成了「蝉沐风」。

如果一个事务读到了另一个**未提交事务**修改过的数据，而导致了前后两次读取的数据不一致的情况，这种事务并发问题叫做**脏读**。



### 3.2. 不可重复读

同样是`T1`和`T2`两个事务，`T1`通过`id=1`查询到了一条数据，然后`T2`紧接着`UPDATE`（`DELETE`也可以）了该条记录，不同的是，`T2`紧接着通过`COMMIT`提交了事务。

![image-20220418144329110](G:\data\LNMRP\$Image\MySQL\20)

此时，`T1`再次执行相同的查询操作，会发现数据发生了变化，`name`字段由「王刚蛋」变成了「蝉沐风」。

如果一个事务读到了另一个**已提交事务**修改过的（或者是删除的）数据，而导致了前后两次读取的数据不一致的情况，这种事务并发问题叫做**不可重复读**。

看到这里是不是有点懵了？怎么读到未提交事务修改的数据是并发问题，读到已提交事务修改的数据还是并发问题呢？

这里先不急着回答你，因为还有个幻读呢。



### 3.3. 幻读













