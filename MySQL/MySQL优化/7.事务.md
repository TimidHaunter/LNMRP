https://www.chanmufeng.com/posts/storage/MySQL/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E4%B8%8EMVCC.html



## 1.事务定义

**事务**就是包含有限个（单条或多条）数据库操作（增删改查）的、最小的逻辑工作单元（原子性）（不可再分）。保证数据最终的一致性。

事务的英文是transaction，直译为“交易”的意思。

![tr](G:\data\LNMRP\$Image\Redis\tr.png)

>A 账户余额-100
>
>B 账户余额+100

目前只有InnoDB和NDB存储引擎支持事务。



## 2.事务的特性

**ACID**

- 原子性（Atomicity）：当前事务的操作要么同时成功，要么同时失败。原子性由undo log日志来保证。
- 一致性（Consistency）：使用事务的最终目的，由**业务代码**正确逻辑保证。
- 隔离性（lsolation）：在事务并发执行时，他们内部的操作不能互相干扰。
- 持久性（Durability）：一旦提交了事务，它对数据库的改变就应该是永久性的持久性由redo log日志来保证。



## 2.1.undo log

> 生成订单，扣减库存
>
> insert 订单表，生成记录，id如果是2
>
> undo log日志，生成一个delete id=2记录



## 2.2.隔离性

lnnoDB引擎中，定义了四种隔离级别供我们使用，级别越高事务隔离性越好，但性能就越低，而隔离性是由MySQL的各种锁以及MVCC机制来实现的。MySQL**默认**是【REPEATABLE-READ】。

- read uncommit（读未提交）：有脏读问题
- read commit（读已提交）：有不可重复读问题
- repeatable read（可重复读）：有读问题
- serializable（串行）：上面问题全部解决

```sql
##查看当前数据库使用的事务隔离级别
show variables like 'tx_isolation';

##设置事务隔离级别
set tx_isolation='read-uncommit';

##MySQL版本8.0以上，两种查看当前数据库使用的事务隔离级别方法
show variables like 'transaction_isolation';
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.00 sec)

select @@transaction_isolation;
+-------------------------+
| @@transaction_isolation |
+-------------------------+
| REPEATABLE-READ         |
+-------------------------+
1 row in set (0.00 sec)

##设置事务隔离级别
set transaction_isolation='read-uncommit';
```



```sql
##表结构和数据
mysql> select * from account;
+----+-----------+---------+
| id | name      | balance |
+----+-----------+---------+
|  1 | LiLei     | 0       |
|  2 | HanMeimei | 10000   |
|  3 | Lucy      | 20000   |
+----+-----------+---------+
3 rows in set (0.00 sec)
```



### 2.2.1.读未提交，有脏读的问题

事务B读了事务A没有提交的记录

```sql
##---客户端A开始---
set transaction_isolation='read-uncommitted';

##开启事务
BEGIN;
update account set balance=balance+500 where id=1;
##---客户端A结束---



##---客户端B开始---
set transaction_isolation='read-uncommitted';

##开启事务
BEGIN;
select * from account where id=1;
##---客户端B结束---



##---客户端B读到的结果---
mysql> select * from account where id=1;
+----+-------+---------+
| id | name  | balance |
+----+-------+---------+
|  1 | LiLei | 500     |
+----+-------+---------+
1 row in set (0.00 sec)



##客户端A再执行数据回滚
RollBack;

##客户端B读到的结果
mysql> select * from account where id=1;
+----+-------+---------+
| id | name  | balance |
+----+-------+---------+
|  1 | LiLei | 0       |
+----+-------+---------+
1 row in set (0.00 sec)
```







## 2.MySql 事务语法



### 2.1.自动提交

当我运行这样单独一条更新语句的时候，它会有事务吗？

```sql
UPDATE user SET name = 'Yintian' WHERE id = 1;
```

 MySQL默认使用**自动提交**事务。在此方式下，增删改的SQL语句会自动开启事务，并且是一条SQL一个事务。

自动提交的方式虽然简单，但是对于转账这种涉及到多条SQL的业务，就不太适合了。因此，MySQL提供了手动开启事务的方法。



### 2.2.手动操作

#### 2.2.1.开启事务

可以使用下面两种语句开启一个事务

- `BEGIN`

- `START TRANSACTION`

>对比`BEGIN`而言，`START TRANSACTION`后面可以添加一些操作符，不过这不是我们的研究重点，可以不必理会。



#### 2.2.2. 提交或回滚

开启事务之后就可以继续编写需要放到当前事务中的SQL语句了。当写完最后一条语句，如果你觉得写得没问题，你可以提交事务；反之你后悔了，想把数据库恢复到之前的状态，你可以回滚事务。

- 提交事务 `COMMIT`
- 回滚事务 `ROLLBACK`



### 2.3. autocommit系统变量

MySQL提供了一个叫做`autocommit`的系统变量，用来表示是否开启自动提交：

```mysql
mysql> SHOW VARIABLES LIKE 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
```

`autocommit`的默认值为`ON`，表示默认开启自动提交。但是自动提交和手动操作事务并不冲突，如果不显式使用`BEGIN`或`START TRANSACTION`开启一个事务，那么InnoDB会在每一条增删改语句执行之后提交事务。

如果我们把`autocommit`设为`OFF`，除非我们手动使用`BEGIN`或`START TRANSACTION`开启一个事务，否则InnoDB绝不会自动开启事务；同样，除非我们使用`COMMIT`或`ROLLBACK`提交或回滚事务，否则InnoDB不会自动结束事务。

> 实际上，InnoDB会因为**某些特殊语句的执行**或**客户端连接断开**等特殊情况而导致事务自动提交（即使我们没有手动输入`COMMIT`），这种情况叫做**隐式提交**。



##  3. 事务并发执行导致的读问题

MySQL会使用独立的线程处理每一个客户端的连接，这就是多线程。每个线程都可以开启事务，这就是事务的并发。

不管是多线程的并发执行还是事务的并发执行（其实本质上是一回事儿），如果不采取点措施，都会带来一些问题。

### 3.1. 脏读

假设事务`T1`和`T2`并发执行，都要访问`user`表中`id`为`1`的数据，不同的是`T1`先读取数据，紧接着`T2`修改了数据的`name`字段，需要注意的是，`T2`并没有提交！

![image-20220418142616460](G:\data\LNMRP\$Image\Redis\20.png)

此时，`T1`再次执行相同的查询操作，会发现数据发生了变化，`name`字段由「王刚蛋」变成了「蝉沐风」。

如果一个事务读到了另一个**未提交事务**修改过的数据，而导致了前后两次读取的数据不一致的情况，这种事务并发问题叫做**脏读**。



### 3.2. 不可重复读

同样是`T1`和`T2`两个事务，`T1`通过`id=1`查询到了一条数据，然后`T2`紧接着`UPDATE`（`DELETE`也可以）了该条记录，不同的是，`T2`紧接着通过`COMMIT`提交了事务。

![image-20220418144329110](G:\data\LNMRP\$Image\MySQL\20)

此时，`T1`再次执行相同的查询操作，会发现数据发生了变化，`name`字段由「王刚蛋」变成了「蝉沐风」。

如果一个事务读到了另一个**已提交事务**修改过的（或者是删除的）数据，而导致了前后两次读取的数据不一致的情况，这种事务并发问题叫做**不可重复读**。

看到这里是不是有点懵了？怎么读到未提交事务修改的数据是并发问题，读到已提交事务修改的数据还是并发问题呢？

这里先不急着回答你，因为还有个幻读呢。



### 3.3. 幻读

还是`T1`和`T2`这俩货，`T1`先查找了所有`name`为「王刚蛋」的用户信息，此时发现拥有这个硬汉名字的用户只有一个。然后`T2`插入了一个同样叫做「王刚蛋」的用户的信息，并且提交了。

![image-20220418150817586](G:\data\LNMRP\$Image\MySQL\2022-04-18-070817.png)



此时，`T1`再次执行相同的查询操作，发现相比上次的查询结果多了一行数据，不由得怀疑自己是不是出了幻觉。

如果一个事务首先根据某些搜索条件P查询出一些结果，另一个事务写入（可以是`INSERT`，`UPDATE`）了一些符合搜索条件P的数据，此时前一个事务再次读取符合条件P的记录时就会获取到之前没有读取过的记录。这个现象叫做**幻读**。











