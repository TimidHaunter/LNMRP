
## explain SQL语句

[MySQL优化从执行计划开始(explain超详细)](https://www.bilibili.com/read/cv10326120)

```sql
explain select * from book \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: book
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 4
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```
> id：执行计划中表每一步加载顺序
>
> select_type：每一步的查询类型
>
> table：涉及的表名
>  
> partitions：
>
> type：访问类型
>
> possible_keys：可能用到的索引
>
> key：实际用到的索引
>
> key_len：实际用到的索引长度
>
> ref：表之间的引用关系
>
> rows：通过索引查到的数据量
>
> filtered：
>
> Extra：额外信息

## 准备数据

## id

### id相同
```sql
explain
select t.id,t.user_name,r.role_name
from user as t
join user_role as tr on t.id = tr.user_id
join role as r on tr.role_id = r.id;
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1927971/1644824799870-767b86c7-6a6d-4bb8-a70d-1313aea00ece.png#clientId=u9a36c93c-b7ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=264&id=u68473300&margin=%5Bobject%20Object%5D&name=image.png&originHeight=528&originWidth=3132&originalType=binary&ratio=1&rotation=0&showTitle=false&size=120690&status=done&style=none&taskId=u94727339-dfd5-4c8d-bae5-dfceee7968c&title=&width=1566)

从上向下执行，`t->tr->r`


### id不同
```sql
explain
select t.id,t.menu_name,t.menu_url
from menu as t where t.id in(
    select menu_id from role_menu as rm where rm.role_id in(
        select role_id from user_role as ur where ur.user_id=1
    )
);
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1927971/1644832352768-412d58b3-4996-483e-a54e-0e1a86c5f744.png#clientId=u9a36c93c-b7ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=321&id=uc776d64f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=642&originWidth=3026&originalType=binary&ratio=1&rotation=0&showTitle=false&size=347243&status=done&style=none&taskId=u99d27a96-6f9b-4412-a06e-ebb990c4967&title=&width=1513)

从id大向id小的执行，`ur->rm-><subquery2>->t`，**subquery2**是衍生表，衍生表就是本来不存在的表，经过`select`等一系列的操作从表中拿出去来，新生成了一张表。

## select_type
### SIMPLE
简单的select查询，不包含子查询或者union

```sql
explain
select * from user;
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1927971/1644850595615-4d23bfcd-6a4c-4a1b-abc2-9c8256c4030a.png#clientId=udde0b700-9f2c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=165&id=u95892a90&margin=%5Bobject%20Object%5D&name=image.png&originHeight=330&originWidth=1838&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49140&status=done&style=none&taskId=u264c8296-04d2-40c1-aedc-75ffc474fdd&title=&width=919)

### PRIMARY
查询语句中包含其他子查询或UNION操作，那最**外层**的`SELECT`就被标记为该类型

```sql
explain
select * from user_role as ur
where ur.user_id=(
    select id from user where id=1
);
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1927971/1644851006684-f7fb0d0a-a04e-48dc-a2c5-2180b7c2b28b.png#clientId=udde0b700-9f2c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u9088de6c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=486&originWidth=2012&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82299&status=done&style=none&taskId=ub6ef73f3-9d07-4dfe-8617-1a246f1f5b5&title=&width=1006)

执行顺序 `user->ur`

### SUBQUERY
在`SELECT`或`WHERE`中包含的子查询会被标记为该类型
见**PRIMARY**图，当存在子查询时，会将子查询标记为**SUBQUERY**

### MATERIALIZED
被物化的子查询，即针对对应的子查询将其物化为一个临时表

```sql
explain
select t.id,t.menu_name,t.menu_url
from menu as t where t.id in(
    select menu_id from role_menu as rm where rm.role_id in(
        select role_id from user_role as ur where ur.user_id=1
    )
);
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1927971/1644852212905-45665aa7-96e3-4f55-b1f2-338b9b9b3e49.png#clientId=udde0b700-9f2c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=319&id=u17a936d8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=638&originWidth=3008&originalType=binary&ratio=1&rotation=0&showTitle=false&size=143094&status=done&style=none&taskId=ub7c197c7-8f0d-42d5-90a3-3f7f466aac3&title=&width=1504)

`ur->rm-><subquery2>->t`

如上图所示，将子查询物化为一个临时表**subquery2**，这个功能是可以通过设置优化器对应的开关的。
### DERIVED

在FROM之后的子查询会被标记为该类型，同样会把结果放在一个临时表中

```sql
explain
select tm.menu_name,rm.role_id from (
    select * from menu where id >3
) as tm, role_menu as rm 
where tm.id=rm.menu_id and rm.role_id=1;
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1927971/1644852854714-509ce5c9-dfed-463c-9ed1-bbe2013f24d6.png#clientId=udde0b700-9f2c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=ud1ec55b2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=484&originWidth=2392&originalType=binary&ratio=1&rotation=0&showTitle=false&size=95089&status=done&style=none&taskId=u75039d9a-fc42-4dd7-b2db-6a5ea04ae19&title=&width=1196)


如图所示，FROM后面跟的子查询就被标记为DERIVED，对应步骤产生的衍生表为derived2。高版本好像对其进行了优化，8.0版本这种形式认为是简单查询。

### UNION
UNION操作中，查询中处于内层的SELECT

```sql
explain
select * from user_role as t1 where t1.user_id=1
union
select * from user_role as t2 where t2.user_id=2;
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1927971/1644853024522-2e0d6627-9cff-4895-afb8-dffe036116ce.png#clientId=udde0b700-9f2c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u6288e8e2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=486&originWidth=2128&originalType=binary&ratio=1&rotation=0&showTitle=false&size=91204&status=done&style=none&taskId=u2f211e37-5ac2-4309-ba21-08d49ff72e1&title=&width=1064)

如上图所示，将第二个SELECT标注为UNION ，即对应加载的表为T2。

### UNIOIN RESULT
UNION操作的结果，对应的id为空，代表的是一个结果集。

见UNIOIN图，UNIOIN RESULT代表的是UNION之后的结果，对应id为空。

## type
代表访问类型，MySQL内部将其分为多类型，常用的类型**从好到差的顺序**展示如下：

`system->const->eq_ef->ref->fulltext->ref_or_null->index_merge->unique_subquery->index_subquery->range->index->ALL;`

而在实际开发场景中，比较常见的几种类型如下：`const->eq_ref->ref->range->index->ALL` **（顺序从好到差）**，通常优化至少在`range`级别或以上，比如`ref`算是比较不错的啦；

上面说到的从好到差指的是查询性能。

### const
表示通过索引一次就找到数据，用于比较**primary key**或者**unique**索引，很快就能找到对应的数据。
```sql
explain
select id,user_name from user where id=1;
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1927971/1644888531667-dbc31b46-0ba7-4687-8ddb-8317c6fea9e2.png#clientId=udde0b700-9f2c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=162&id=u7c081ef4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=324&originWidth=1926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52793&status=done&style=none&taskId=ue7e96266-324d-4a94-82ab-4cf1d5438d9&title=&width=963)

## table
table代表对应步骤加载的是哪张表，中间会出现一些临时表，比如subquery2、derived2等这种临时表，最后的数字代表产生该表对应步骤的id。

## type


## Extra
```sql
# 数据准备
create table user_extra (
    id int primary key,
    name varchar(20),
    sex varchar(5),
    index(name)
)engine=innodb;

insert into user_extra values(1, 'shenjian','no');
insert into user_extra values(2, 'zhangsan','no');
insert into user_extra values(3, 'lisi', 'yes');
insert into user_extra values(4, 'lisi', 'no');
```
数据说明：

> 用户表：id主键索引，name普通索引（非唯一），sex无索引
>
> 插入数据：其中name普通索引存在重复数据lisi

## Using index

性能提升，`索引覆盖`，SQL所需要返回的所有列数据均在一棵索引树上，而无需访问实际的行记录（只查询索引表，不需要回表查询）。

```sql
explain  select id,name from user_extra where name='shenjian' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: user_extra
   partitions: NULL
         type: ref
possible_keys: name
          key: name
      key_len: 83
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)
```

**那么，什么样的列数据，会包含在索引树上呢？**

## Using where
需要回表查询，假设 `name` 是索引列，但是查询语句 `sex` 是没有索引的，就需要回表查询。
```sql
explain select name,sex from user_extra where sex='' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: user_extra
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 4
     filtered: 25.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

## Using filesort

## Using temporary
性能损耗比较大，用到了临时表。一般用于 `group by` 语句中。

```sql
# 建表的时候加上索引
create table test_temporary
(
    a1 char(3),
    a2 char(3),
    a3 char(3),
    a4 char(3),
    # 创建一个复合索引
    index idx_a1_a2_a3_a4(a1, a2, a3, a4)
);

explain
select * from test_temporary where a1 in('1', '2', '3') group by a1;

# 查的时候按a1，分组的时候按a2
explain
select * from test_temporary where a1 in('1', '2', '3') group by a2;

mysql> explain select * from test_temporary where a1 in('1', '2', '3') group by a1\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: test_temporary
   partitions: NULL
         type: index
possible_keys: idx_a1_a2_a3_a4
          key: idx_a1_a2_a3_a4
      key_len: 52
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using where; Using index
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from test_temporary where a1 in('1', '2', '3') group by a2\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: test_temporary
   partitions: NULL
         type: index
possible_keys: idx_a1_a2_a3_a4
          key: idx_a1_a2_a3_a4
      key_len: 52
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using where; Using index; Using temporary
1 row in set, 1 warning (0.00 sec)
```

避免：查询那些列，就根据那些列分组

## Using join buffer
MySQL 引擎使用了链接缓存，SQL写的太差了，MySQL给你加的。